apply plugin: 'com.android.application'

println getRootDir()
println getBuildDir()
println getProjectDir()

//寻找当前目录下的文件
//println file('app.iml').text
//new File需要传入绝对路径
//def file1 = new File('xxxxx/app.iml')

android {
    compileSdkVersion compileSdkVersionForProperities.toInteger()
//    compileSdkVersion rootProject.ext.android.compileSdkVersionForExtFile
//    compileSdkVersion rootProject.mCompileSdkVersionRoot
    defaultConfig {
        applicationId "com.xk.myapplication"
        minSdkVersion 14
        targetSdkVersion 28
        versionCode rootProject.ext.android.versionCode
        versionName rootProject.ext.android.versionName
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}

dependencies {
    //添加一个文件树依赖，亦可以添加一个文件 或多个文件
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation rootProject.ext.dependencies.appcompat
    implementation 'com.android.support.constraint:constraint-layout:1.1.3'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'com.android.support.test:runner:1.0.2'
    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'

    //我们自己依赖了一个A库，然后这个三方库也依赖了这个A库，但是版本不同，可以通过这种方法排除三方库中的A
//    implementation '三方库' {
    //可以通过module或者group或者结合起来排除
//        exclude module: '想要排除的冲突库的module'
//        exclude group: '想要排除的冲突库的group'

//        transitive false //禁止传递依赖 新版gradle应该可以通过api compile implementation来解决，最好不要用传递依赖，因为那个依赖api可能会改变
    //A依赖B,B依赖C，如果打开传递依赖，那么A也可以调用C的方法，但是当B更新之后，C的api可能会改变，所以比较有风险。
    //解决方法是让A同依赖B和C，这样不用担心C改变了，但是又可能会引入冲突问题，就可以通过上面的方法去解决

    //旧版本provided（只在编译时读取，不会打包到输出产物中）的使用场景：1.例如tinker库，他只需要编译时生成一个application，然后就没用了，不需要打入到输出的产物中。
    //2.当前工程是一个库工程，它依赖的库已经在主工程中依赖过了，编译时通过就好了。运行时使用的主工程依赖的库
//    }
}

//copy{//拷贝文件、文件夹
//    def sourceFile  = file('build')
//    from sourceFile//把xxx
//    into getRootProject().getBuildDir()//拷贝到当前目录
//    exclude{
//        //排除不想拷贝的文件
//    }
//    rename {
//        //重命名文件
//    }
//
//}

//对文件树进行遍历
//fileTree('build') {
//    FileTree fileTree ->
//        fileTree.visit {
//            FileTreeElement fileTreeElement ->
//                println(fileTreeElement)
//                copy{
//                    from fileTreeElement.file
//                    into getRootProject().path+"/test/"
//                }
//        }
//}

//执行外部命令
task "apkcopy" {
    doLast {
        def sourceFilePath = getBuildDir().path + "/outputs/apk"
        def desFilePath = '/Users/xuekai/Desktop/'
        //执行的命令，配置不同的command，可以执行各种外部命令包括java等
        def command = "mv -f ${sourceFilePath} ${desFilePath}"
        //执行外部命令，传入一个闭包
        exec {
            try {
                //外部命令都是bash
                executable 'bash'
                //可以执行命令，java，android等各种代码
                args '-c', command
                println 'over!!!!!!'
            } catch (e) {
                println 'error!!!!!!'
            }
        }

    }
}

task "createFile" {
    doLast {
        clean1
        def newFile = new File("/Users/xuekai/projects/as_workspace/MyApplication/app/src/main/java/com/xk/myapplication/abc.java")
        if (!newFile.exists()) {
            newFile.createNewFile()
        }
        newFile.withWriter {
            it.write('''package com.xk.myapplication;
import android.app.Application;


public class abc extends Application {

}
''')
        }
    }
}

//tasks('clean1'){
//    doLast{
//        println "clena===="
//        createFile
//    }
//}

//=========task的创建方式
//1.直接通过task(String name)创建一个task
task helloTask1(group: 'hello', description: 'task study') {
    println 'hello1'

    doFirst {
        println('hello1 first')
    }
    doLast {
        println('hello1 last')
    }
}
//2.通过TaskContaners（管理task）创建。project中有taskContaner，用来管理task。
tasks.create('helloTask2') {
    setGroup('hello')
    setDescription('task study')
    println 'hello2'
    doFirst {
        println('hello2 first')
    }
    doLast {
        println('hello2 last')
    }
}

task lib1 << {
    println 'lib1 的doLast'
}
task lib2 << {
    println 'lib2 的doLast'
}

task taskA {
    //taskA的配置阶段指定他的依赖
    //1.静态指定
//    dependsOn(lib1)
    //2.静态指定
//    dependsOn lib1
    //3.动态指定
    dependsOn tasks.findAll {
        //通过一个条件，过滤出task,最后findAll返回一个set集合
        return it.name.startsWith("lib")
    }
    doLast {
        println 'taskA doLast'
    }
}

//====计算build时长
def startBuildTime, endBuildTime
afterEvaluate {
        //在这个生命周期中是为了保证要找的task都已经配置完毕
    Project project ->
        //1.找到preBuildtasd
        def preBuildTask = project.tasks.findByPath('preBuild')
        preBuildTask.doFirst {
            //在preBuildTask之前开始做事情
            startBuildTime = System.currentTimeMillis()
        }
        //2.找到buildtask
        def buildTask = project.tasks.findByPath('build')
        buildTask.doLast {
            //在preBuildTask之前开始做事情
            endBuildTime = System.currentTimeMillis()
            println endBuildTime - startBuildTime
        }
}

//========task 依赖

task task1 {
    doLast {
        println 'task1'
    }
}
task task2 {
    doLast {
        println 'task2'
    }
}
//1.定义的时候配置
task task3(dependsOn: [task1, task2]) {
    doLast {
        println 'task3'
    }
}
//2.额外配置
//task2.dependsOn(task1)
task3.dependsOn(task1, task2)

//=========处理release.xml
task handleReleaseXml {
    def srcFile = file('releases.xml')
    doLast {
        def rootNode = new XmlParser().parse(srcFile)

        def desFile = new File(projectDir, "/release/")
        rootNode.release.each {
            releaseNode ->
                desFile.mkdir()

                def file = new File(desFile, "release-${releaseNode.versionName.text()}")
                file.createNewFile()
                file.withWriter {
                    writer ->
                        writer.writeLine(releaseNode.versionCode.text() + releaseNode.versionName.text() + releaseNode.versionInfo.text())
                }
        }

    }
}

task handleReleaseXmlTest(dependsOn: handleReleaseXml) {
    doLast {
        println "执行该test，由于她依赖了handleReleaseXml，所以会先执行handleReleaseXml，然后在这里可以进行一些测试"
    }
}

//=========以上通过dependsOn决定了两个task的依赖关系。下面是通过input ouput来定义两个task的依赖关系（执行顺序）

ext {
    versionName = rootProject.ext.android.versionName
    versionCode = rootProject.ext.android.versionCode
    updateLog = "根据网络获取，传入versionCode，网络返回日志22"+System.currentTimeMillis()
    def destPath = file("release.xml")
    if (!destPath.exists()) {
        destPath.createNewFile()
    }
    destFile = destPath.path

}
//通过配置阶段，网络请求拿到版本号，更新信息等数据，写入到release.xml中
import groovy.xml.MarkupBuilder

task writeDataToRelease {
    inputs.property("versionCode", "$versionCode")
    inputs.properties("versionName": "$versionName", "updateLog": "${updateLog}")
    outputs.file(destFile)
    println "configWrite"

    doLast {
        println "readRelease"
        def properties = inputs.properties
        File outputFile = outputs.getFiles().getSingleFile()

        def sw = new StringWriter()

        def content = outputFile.text
        if (content != null && content.size() <= 0) {
            //原来文件是空的
            def builder = new MarkupBuilder(sw)
            //生成releases节点
            builder.releases {
                //以下生成3个release节点，用不同的方式，具体看效果
                release("${updateLog}", "versionCode": "$versionCode", "versionName": "$versionName",)
                release("versionCode": "$versionCode", "versionName": "$versionName", "${updateLog}")
                release("versionCode": "$versionCode") {
                    versionName("$versionName")
                    updateLog("$updateLog")
                }
            }
            outputFile.withWriter {
                writer ->
                    writer.append(sw.toString())
            }
        } else {
            //原来文件不空
            def builder = new MarkupBuilder(sw)
            //以下生成3个release节点，用不同的方式，具体看效果
            builder.release("${updateLog}", "versionCode": "$versionCode", "versionName": "$versionName",)
            builder.release("versionCode": "$versionCode", "versionName": "$versionName", "${updateLog}")
            builder.release("versionCode": "$versionCode") {
                versionName("$versionName")
                updateLog("$updateLog")
            }
            outputFile.withReader {
                BufferedReader reader ->
                    def lines = reader.readLines()
                    outputFile.withWriter {
                        writer ->
                            lines.each {
                                line ->
                                    if (line.contains("/releases")) {
                                        //最后一行
//                                        println "writeLastLine"
                                        writer.write(sw.toString())
                                    }
//                                    println "writeLine"
                                    writer.writeLine(line)
                            }
                    }
            }
        }
    }
}
task readRelease1 {
    inputs.file(destFile)
    doLast {
        def file = inputs.files.singleFile
        println "readRelease1"
    }
}
task readRelease {
    inputs.file(destFile)
    println "configReader"
    doLast {
        def file = inputs.files.singleFile
        println "readRelease"
    }
}


task inputOutputTest(dependsOn: [readRelease1,readRelease, writeDataToRelease]) {
    println "inputOutputTest"
    doLast {
        println "inputOutputTest"
    }
}