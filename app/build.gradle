apply plugin: 'com.android.application'





def mylibrary = rootProject.project('mylibrary')
def releaseUtils = mylibrary.file('releaseUtils.gradle')
apply from: releaseUtils

//寻找当前目录下的文件
//println file('app.iml').text
//new File需要传入绝对路径
//def file1 = new File('xxxxx/app.iml')

android {
    compileSdkVersion compileSdkVersionForProperities.toInteger()
//    compileSdkVersion rootProject.ext.android.compileSdkVersionForExtFile
//    compileSdkVersion rootProject.mCompileSdkVersionRoot
    defaultConfig {
        applicationId "com.xk.myapplication"
        minSdkVersion 14
        targetSdkVersion 28
        versionCode rootProject.ext.android.versionCode
        versionName rootProject.ext.android.versionName
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
    //修改sourcesets
    sourceSets {
        main {
            jniLibs.srcDirs = ['src/main/newLibs']//修改jniLibs的新目录
            res.srcDirs = ['src/main/res', 'src/main/res-ad']//修改res目录
//            java.srcDirs=['src/mjava']//修改java文件的路径
        }
    }
}
//apply plugin: MPlugin

//也可以通过android调用sourcesets，因为他是一个方法
android.sourceSets {
    main {
        jniLibs.srcDirs = ['src/main/newLibs']//修改jniLibs的新目录
        res.srcDirs = ['src/main/res', 'src/main/res-ad']//修改res目录
//            java.srcDirs=['src/mjava']//修改java文件的路径
    }
}

dependencies {
    //添加一个文件树依赖，亦可以添加一个文件 或多个文件
    implementation fileTree(include: ['*.jar'], dir: 'libs')
    implementation rootProject.ext.dependencies.appcompat
    implementation 'com.android.support.constraint:constraint-layout:1.1.3'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'com.android.support.test:runner:1.0.2'
    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
    //我们自己依赖了一个A库，然后这个三方库也依赖了这个A库，但是版本不同，可以通过这种方法排除三方库中的A
    //    implementation '三方库' {
    //可以通过module或者group或者结合起来排除
    //        exclude module: '想要排除的冲突库的module'
    //        exclude group: '想要排除的冲突库的group'
    //        transitive false //禁止传递依赖 新版gradle应该可以通过api compile implementation来解决，最好不要用传递依赖，因为那个依赖api可能会改变
    //A依赖B,B依赖C，如果打开传递依赖，那么A也可以调用C的方法，但是当B更新之后，C的api可能会改变，所以比较有风险。
    //解决方法是让A同依赖B和C，这样不用担心C改变了，但是又可能会引入冲突问题，就可以通过上面的方法去解决
    //旧版本provided（只在编译时读取，不会打包到输出产物中）的使用场景：1.例如tinker库，他只需要编译时生成一个application，然后就没用了，不需要打入到输出的产物中。
    //2.当前工程是一个库工程，它依赖的库已经在主工程中依赖过了，编译时通过就好了。运行时使用的主工程依赖的库
    //    }
}

//copy{//拷贝文件、文件夹
//    def sourceFile  = file('build')
//    from sourceFile//把xxx
//    into getRootProject().getBuildDir()//拷贝到当前目录
//    exclude{
//        //排除不想拷贝的文件
//    }
//    rename {
//        //重命名文件
//    }
//
//}

//对文件树进行遍历
//fileTree('build') {
//    FileTree fileTree ->
//        fileTree.visit {
//            FileTreeElement fileTreeElement ->
//                println(fileTreeElement)
//                copy{
//                    from fileTreeElement.file
//                    into getRootProject().path+"/test/"
//                }
//        }
//}

//执行外部命令
task "apkcopy" {
    doLast {
        def sourceFilePath = getBuildDir().path + "/outputs/apk"
        def desFilePath = '/Users/xuekai/Desktop/'
        //执行的命令，配置不同的command，可以执行各种外部命令包括java等
        def command = "mv -f ${sourceFilePath} ${desFilePath}"
        //执行外部命令，传入一个闭包
        exec {
            try {
                //外部命令都是bash
                executable 'bash'
                //可以执行命令，java，android等各种代码
                args '-c', command
                println 'over!!!!!!'
            } catch (e) {
                println 'error!!!!!!'
            }
        }

    }
}

task "createFile" {
    doLast {
        clean1
        def newFile = new File("/Users/xuekai/projects/as_workspace/MyApplication/app/src/main/java/com/xk/myapplication/abc.java")
        if (!newFile.exists()) {
            newFile.createNewFile()
        }
        newFile.withWriter {
            it.write('''package com.xk.myapplication;
import android.app.Application;


public class abc extends Application {

}
''')
        }
    }
}

//tasks('clean1'){
//    doLast{
//        println "clena===="
//        createFile
//    }
//}

//=========task的创建方式
//1.直接通过task(String name)创建一个task
task helloTask1(group: 'hello', description: 'task study') {
    println 'hello1'

    doFirst {
        println('hello1 first')
    }
    doLast {
        println('hello1 last')
    }
}
//2.通过TaskContaners（管理task）创建。project中有taskContaner，用来管理task。
tasks.create('helloTask2') {
    setGroup('hello')
    setDescription('task study')
    println 'hello2'
    doFirst {
        println('hello2 first')
    }
    doLast {
        println('hello2 last')
    }
}

task lib1 << {
    println 'lib1 的doLast'
}
task lib2 << {
    println 'lib2 的doLast'
}

task taskA {
    //taskA的配置阶段指定他的依赖
    //1.静态指定
//    dependsOn(lib1)
    //2.静态指定
//    dependsOn lib1
    //3.动态指定
    dependsOn tasks.findAll {
        //通过一个条件，过滤出task,最后findAll返回一个set集合
        return it.name.startsWith("lib")
    }
    doLast {
        println 'taskA doLast'
    }
}

//====计算build时长
def startBuildTime, endBuildTime
afterEvaluate {
        //在这个生命周期中是为了保证要找的task都已经配置完毕
    Project project ->
        //1.找到preBuildtasd
        def preBuildTask = project.tasks.findByPath('preBuild')
        preBuildTask.doFirst {
            //在preBuildTask之前开始做事情
            startBuildTime = System.currentTimeMillis()
        }
        //2.找到buildtask
        def buildTask = project.tasks.findByPath('build')
        buildTask.doLast {
            //在preBuildTask之前开始做事情
            endBuildTime = System.currentTimeMillis()
            println endBuildTime - startBuildTime
        }
}

//========task 依赖

task task1 {
    doLast {
        println 'task1'
    }
}
task task2 {
    doLast {
        println 'task2'
    }
}
//1.定义的时候配置
task task3(dependsOn: [task1, task2]) {
    doLast {
        println 'task3'
    }
}
//2.额外配置
//task2.dependsOn(task1)
task3.dependsOn(task1, task2)

//=========处理release.xml
task handleReleaseXml {
    def srcFile = file('releases.xml')
    doLast {
        def rootNode = new XmlParser().parse(srcFile)

        def desFile = new File(projectDir, "/release/")
        rootNode.release.each {
            releaseNode ->
                desFile.mkdir()

                def file = new File(desFile, "release-${releaseNode.versionName.text()}")
                file.createNewFile()
                file.withWriter {
                    writer ->
                        writer.writeLine(releaseNode.versionCode.text() + releaseNode.versionName.text() + releaseNode.versionInfo.text())
                }
        }

    }
}

task handleReleaseXmlTest(dependsOn: handleReleaseXml) {
    doLast {
        println "执行该test，由于她依赖了handleReleaseXml，所以会先执行handleReleaseXml，然后在这里可以进行一些测试"
    }
}

task ttt {
    doLast {
        task3.execute()
    }
}

afterEvaluate {
    def buildTask = tasks.findByPath('build')
    if (buildTask != null) {
        buildTask.doLast {
            //通过这种execute的方式执行一个task，他的依赖的task不会被执行
            task3.execute()
        }
    }
}

//===========模拟tinker，在系统task之间插入自己的task
task systemA {
    doLast {
        println "systemA"
    }
}

task systemB {
    systemB.mustRunAfter systemA
    doLast {
        println "systemB"
    }
}

task myTask {
    doLast {
        println "myTask"
    }
}

afterEvaluate {
    //mustRunAfter和dependsOn的区别：mustRunAfter是指，如果两个任务都被执行了，这个关系才会成立。但是只执行后面的任务，前面的不会被拉起。
    //dependsOn是指，如果你只执行后面的那个任务，前面的也会被拉起。
    //所以，如果我们给系统声明周期中注入自己task的时候，最好用mustRunAfter，这样不会干扰系统内部的运行，但是有时候必须用dependsOn，因为你的任务需要被拉起，如下
    //以下为推荐写法
    myTask.mustRunAfter systemA
    systemB.dependsOn myTask
//    以下为不推荐写法
//    myTask.dependsOn(systemA)
//    systemB.dependsOn(myTask)
    //    manifestTask.mustRunAfter variantOutput.processManifest

//    variantOutput.processResources.dependsOn manifestTask

//    myTask.mustRunAfter(systemA)
//    systemB.mustRunAfter(myTask)

}